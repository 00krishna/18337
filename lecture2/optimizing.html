<!DOCTYPE html>
<HTML lang = "en">
<HEAD>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Optimizing Serial Code</title>
  

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script>

  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  
<style>
pre.hljl {
    border: 1px solid #ccc;
    margin: 5px;
    padding: 5px;
    overflow-x: auto;
    color: rgb(68,68,68); background-color: rgb(251,251,251); }
pre.hljl > span.hljl-t { }
pre.hljl > span.hljl-w { }
pre.hljl > span.hljl-e { }
pre.hljl > span.hljl-eB { }
pre.hljl > span.hljl-o { }
pre.hljl > span.hljl-k { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kc { color: rgb(59,151,46); font-style: italic; }
pre.hljl > span.hljl-kd { color: rgb(214,102,97); font-style: italic; }
pre.hljl > span.hljl-kn { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kp { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kr { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-kt { color: rgb(148,91,176); font-weight: bold; }
pre.hljl > span.hljl-n { }
pre.hljl > span.hljl-na { }
pre.hljl > span.hljl-nb { }
pre.hljl > span.hljl-nbp { }
pre.hljl > span.hljl-nc { }
pre.hljl > span.hljl-ncB { }
pre.hljl > span.hljl-nd { color: rgb(214,102,97); }
pre.hljl > span.hljl-ne { }
pre.hljl > span.hljl-neB { }
pre.hljl > span.hljl-nf { color: rgb(66,102,213); }
pre.hljl > span.hljl-nfm { color: rgb(66,102,213); }
pre.hljl > span.hljl-np { }
pre.hljl > span.hljl-nl { }
pre.hljl > span.hljl-nn { }
pre.hljl > span.hljl-no { }
pre.hljl > span.hljl-nt { }
pre.hljl > span.hljl-nv { }
pre.hljl > span.hljl-nvc { }
pre.hljl > span.hljl-nvg { }
pre.hljl > span.hljl-nvi { }
pre.hljl > span.hljl-nvm { }
pre.hljl > span.hljl-l { }
pre.hljl > span.hljl-ld { color: rgb(148,91,176); font-style: italic; }
pre.hljl > span.hljl-s { color: rgb(201,61,57); }
pre.hljl > span.hljl-sa { color: rgb(201,61,57); }
pre.hljl > span.hljl-sb { color: rgb(201,61,57); }
pre.hljl > span.hljl-sc { color: rgb(201,61,57); }
pre.hljl > span.hljl-sd { color: rgb(201,61,57); }
pre.hljl > span.hljl-sdB { color: rgb(201,61,57); }
pre.hljl > span.hljl-sdC { color: rgb(201,61,57); }
pre.hljl > span.hljl-se { color: rgb(59,151,46); }
pre.hljl > span.hljl-sh { color: rgb(201,61,57); }
pre.hljl > span.hljl-si { }
pre.hljl > span.hljl-so { color: rgb(201,61,57); }
pre.hljl > span.hljl-sr { color: rgb(201,61,57); }
pre.hljl > span.hljl-ss { color: rgb(201,61,57); }
pre.hljl > span.hljl-ssB { color: rgb(201,61,57); }
pre.hljl > span.hljl-nB { color: rgb(59,151,46); }
pre.hljl > span.hljl-nbB { color: rgb(59,151,46); }
pre.hljl > span.hljl-nfB { color: rgb(59,151,46); }
pre.hljl > span.hljl-nh { color: rgb(59,151,46); }
pre.hljl > span.hljl-ni { color: rgb(59,151,46); }
pre.hljl > span.hljl-nil { color: rgb(59,151,46); }
pre.hljl > span.hljl-noB { color: rgb(59,151,46); }
pre.hljl > span.hljl-oB { color: rgb(102,102,102); font-weight: bold; }
pre.hljl > span.hljl-ow { color: rgb(102,102,102); font-weight: bold; }
pre.hljl > span.hljl-p { }
pre.hljl > span.hljl-c { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-ch { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cm { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cp { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cpB { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-cs { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-csB { color: rgb(153,153,119); font-style: italic; }
pre.hljl > span.hljl-g { }
pre.hljl > span.hljl-gd { }
pre.hljl > span.hljl-ge { }
pre.hljl > span.hljl-geB { }
pre.hljl > span.hljl-gh { }
pre.hljl > span.hljl-gi { }
pre.hljl > span.hljl-go { }
pre.hljl > span.hljl-gp { }
pre.hljl > span.hljl-gs { }
pre.hljl > span.hljl-gsB { }
pre.hljl > span.hljl-gt { }
</style>



  <style type="text/css">
  @font-face {
  font-style: normal;
  font-weight: 300;
}
@font-face {
  font-style: normal;
  font-weight: 400;
}
@font-face {
  font-style: normal;
  font-weight: 600;
}
html {
  font-family: sans-serif; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
}
body {
  margin: 0;
}
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}
audio,
canvas,
progress,
video {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}
audio:not([controls]) {
  display: none;
  height: 0;
}
[hidden],
template {
  display: none;
}
a:active,
a:hover {
  outline: 0;
}
abbr[title] {
  border-bottom: 1px dotted;
}
b,
strong {
  font-weight: bold;
}
dfn {
  font-style: italic;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
mark {
  background: #ff0;
  color: #000;
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sup {
  top: -0.5em;
}
sub {
  bottom: -0.25em;
}
img {
  border: 0;
}
svg:not(:root) {
  overflow: hidden;
}
figure {
  margin: 1em 40px;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}
pre {
  overflow: auto;
}
code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}
button,
input,
optgroup,
select,
textarea {
  color: inherit; /* 1 */
  font: inherit; /* 2 */
  margin: 0; /* 3 */
}
button {
  overflow: visible;
}
button,
select {
  text-transform: none;
}
button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button; /* 2 */
  cursor: pointer; /* 3 */
}
button[disabled],
html input[disabled] {
  cursor: default;
}
button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
input {
  line-height: normal;
}
input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}
input[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box; /* 2 */
  box-sizing: content-box;
}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}
legend {
  border: 0; /* 1 */
  padding: 0; /* 2 */
}
textarea {
  overflow: auto;
}
optgroup {
  font-weight: bold;
}
table {
  font-family: monospace, monospace;
  font-size : 0.8em;
  border-collapse: collapse;
  border-spacing: 0;
}
td,
th {
  padding: 0;
}
thead th {
    border-bottom: 1px solid black;
    background-color: white;
}
tr:nth-child(odd){
  background-color: rgb(248,248,248);
}


/*
* Skeleton V2.0.4
* Copyright 2014, Dave Gamache
* www.getskeleton.com
* Free to use under the MIT license.
* http://www.opensource.org/licenses/mit-license.php
* 12/29/2014
*/
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }
.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }
@media (min-width: 400px) {
  .container {
    width: 85%;
    padding: 0; }
}
@media (min-width: 550px) {
  .container {
    width: 80%; }
  .column,
  .columns {
    margin-left: 4%; }
  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns                    { width: 4.66666666667%; }
  .two.columns                    { width: 13.3333333333%; }
  .three.columns                  { width: 22%;            }
  .four.columns                   { width: 30.6666666667%; }
  .five.columns                   { width: 39.3333333333%; }
  .six.columns                    { width: 48%;            }
  .seven.columns                  { width: 56.6666666667%; }
  .eight.columns                  { width: 65.3333333333%; }
  .nine.columns                   { width: 74.0%;          }
  .ten.columns                    { width: 82.6666666667%; }
  .eleven.columns                 { width: 91.3333333333%; }
  .twelve.columns                 { width: 100%; margin-left: 0; }

  .one-third.column               { width: 30.6666666667%; }
  .two-thirds.column              { width: 65.3333333333%; }

  .one-half.column                { width: 48%; }

  /* Offsets */
  .offset-by-one.column,
  .offset-by-one.columns          { margin-left: 8.66666666667%; }
  .offset-by-two.column,
  .offset-by-two.columns          { margin-left: 17.3333333333%; }
  .offset-by-three.column,
  .offset-by-three.columns        { margin-left: 26%;            }
  .offset-by-four.column,
  .offset-by-four.columns         { margin-left: 34.6666666667%; }
  .offset-by-five.column,
  .offset-by-five.columns         { margin-left: 43.3333333333%; }
  .offset-by-six.column,
  .offset-by-six.columns          { margin-left: 52%;            }
  .offset-by-seven.column,
  .offset-by-seven.columns        { margin-left: 60.6666666667%; }
  .offset-by-eight.column,
  .offset-by-eight.columns        { margin-left: 69.3333333333%; }
  .offset-by-nine.column,
  .offset-by-nine.columns         { margin-left: 78.0%;          }
  .offset-by-ten.column,
  .offset-by-ten.columns          { margin-left: 86.6666666667%; }
  .offset-by-eleven.column,
  .offset-by-eleven.columns       { margin-left: 95.3333333333%; }

  .offset-by-one-third.column,
  .offset-by-one-third.columns    { margin-left: 34.6666666667%; }
  .offset-by-two-thirds.column,
  .offset-by-two-thirds.columns   { margin-left: 69.3333333333%; }

  .offset-by-one-half.column,
  .offset-by-one-half.columns     { margin-left: 52%; }

}
html {
  font-size: 62.5%; }
body {
  font-size: 1.5em; /* currently ems cause chrome bug misinterpreting rems on body element */
  line-height: 1.6;
  font-weight: 400;
  font-family: "Raleway", "HelveticaNeue", "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #222; }
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 2rem;
  font-weight: 300; }
h1 { font-size: 3.6rem; line-height: 1.2;  letter-spacing: -.1rem;}
h2 { font-size: 3.4rem; line-height: 1.25; letter-spacing: -.1rem; }
h3 { font-size: 3.2rem; line-height: 1.3;  letter-spacing: -.1rem; }
h4 { font-size: 2.8rem; line-height: 1.35; letter-spacing: -.08rem; }
h5 { font-size: 2.4rem; line-height: 1.5;  letter-spacing: -.05rem; }
h6 { font-size: 1.5rem; line-height: 1.6;  letter-spacing: 0; }

p {
  margin-top: 0; }
a {
  color: #1EAEDB; }
a:hover {
  color: #0FA0CE; }
.button,
button,
input[type="submit"],
input[type="reset"],
input[type="button"] {
  display: inline-block;
  height: 38px;
  padding: 0 30px;
  color: #555;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  line-height: 38px;
  letter-spacing: .1rem;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  background-color: transparent;
  border-radius: 4px;
  border: 1px solid #bbb;
  cursor: pointer;
  box-sizing: border-box; }
.button:hover,
button:hover,
input[type="submit"]:hover,
input[type="reset"]:hover,
input[type="button"]:hover,
.button:focus,
button:focus,
input[type="submit"]:focus,
input[type="reset"]:focus,
input[type="button"]:focus {
  color: #333;
  border-color: #888;
  outline: 0; }
.button.button-primary,
button.button-primary,
input[type="submit"].button-primary,
input[type="reset"].button-primary,
input[type="button"].button-primary {
  color: #FFF;
  background-color: #33C3F0;
  border-color: #33C3F0; }
.button.button-primary:hover,
button.button-primary:hover,
input[type="submit"].button-primary:hover,
input[type="reset"].button-primary:hover,
input[type="button"].button-primary:hover,
.button.button-primary:focus,
button.button-primary:focus,
input[type="submit"].button-primary:focus,
input[type="reset"].button-primary:focus,
input[type="button"].button-primary:focus {
  color: #FFF;
  background-color: #1EAEDB;
  border-color: #1EAEDB; }
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea,
select {
  height: 38px;
  padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
  background-color: #fff;
  border: 1px solid #D1D1D1;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box; }
/* Removes awkward default styles on some inputs for iOS */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none; }
textarea {
  min-height: 65px;
  padding-top: 6px;
  padding-bottom: 6px; }
input[type="email"]:focus,
input[type="number"]:focus,
input[type="search"]:focus,
input[type="text"]:focus,
input[type="tel"]:focus,
input[type="url"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  border: 1px solid #33C3F0;
  outline: 0; }
label,
legend {
  display: block;
  margin-bottom: .5rem;
  font-weight: 600; }
fieldset {
  padding: 0;
  border-width: 0; }
input[type="checkbox"],
input[type="radio"] {
  display: inline; }
label > .label-body {
  display: inline-block;
  margin-left: .5rem;
  font-weight: normal; }
ul {
  list-style: circle; }
ol {
  list-style: decimal; }
ul ul,
ul ol,
ol ol,
ol ul {
  margin: 1.5rem 0 1.5rem 3rem;
  font-size: 90%; }
li > p {margin : 0;}
th,
td {
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #E1E1E1; }
th:first-child,
td:first-child {
  padding-left: 0; }
th:last-child,
td:last-child {
  padding-right: 0; }
button,
.button {
  margin-bottom: 1rem; }
input,
textarea,
select,
fieldset {
  margin-bottom: 1.5rem; }
pre,
blockquote,
dl,
figure,
table,
p,
ul,
ol,
form {
  margin-bottom: 1.0rem; }
.u-full-width {
  width: 100%;
  box-sizing: border-box; }
.u-max-full-width {
  max-width: 100%;
  box-sizing: border-box; }
.u-pull-right {
  float: right; }
.u-pull-left {
  float: left; }
hr {
  margin-top: 3rem;
  margin-bottom: 3.5rem;
  border-width: 0;
  border-top: 1px solid #E1E1E1; }
.container:after,
.row:after,
.u-cf {
  content: "";
  display: table;
  clear: both; }

pre {
  display: block;
  padding: 9.5px;
  margin: 0 0 10px;
  font-size: 13px;
  line-height: 1.42857143;
  word-break: break-all;
  word-wrap: break-word;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre.hljl {
  margin: 0 0 10px;
  display: block;
  background: #f5f5f5;
  border-radius: 4px;
  padding : 5px;
}

pre.output {
  background: #ffffff;
}

pre.code {
  background: #ffffff;
}

pre.julia-error {
  color : red
}

code,
kbd,
pre,
samp {
  font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
  font-size: 13px;
}


@media (min-width: 400px) {}
@media (min-width: 550px) {}
@media (min-width: 750px) {}
@media (min-width: 1000px) {}
@media (min-width: 1200px) {}

h1.title {margin-top : 20px}
img {max-width : 100%}
div.title {text-align: center;}

  </style>



</HEAD>
  <BODY>
    <div class ="container">
      <div class = "row">
        <div class = "col-md-12 twelve columns">

          <div class="title">
            <h1 class="title">Optimizing Serial Code</h1>
            <h5>Chris Rackauckas</h5>
            <h5>September 3rd, 2019</h5>
          </div>

          <p>At the center of any fast parallel code is a fast serial code. Parallelism is made to be a performance multiplier, so if you start from a bad position it won&#39;t ever get much better. Thus the first thing that we need to do is understand what makes code slow and how to avoid the pitfalls. This discussion of serial code optimization will also directly motivate why we will be using Julia throughout this course.</p>
<h2>Mental Model of a Memory</h2>
<p>To start optimizing code you need a good mental model of a computer.</p>
<h3>High Level View</h3>
<p>At the highest level you have a CPU&#39;s core memory which directly accesses a L1 cache. The L1 cache has the fastest access, so things which will be needed soon are kept there. However, it is filled from the L2 cache, which itself is filled from the L3 cache, which is filled from the main memory. This bring us to the first idea in optimizing code: using things that are already in a closer cache can help the code run faster because it doesn&#39;t have to be queried for and moved up this chain.</p>
<p><img src="https://hackernoon.com/hn-images/1*nT3RAGnOAWmKmvOBnizNtw.png" alt="" /></p>
<p>When something needs to be pulled directly from main memory this is known as a <em>cache miss</em>.</p>
<p>&#40;Cache-aware and cache-oblivious algorithms are methods which change their indexing structure to optimize their use of the cache lines. We will return to this when talking about performance of linear algebra.&#41;</p>
<h3>Cache Lines and Row/Column-Major</h3>
<p>Many algorithms in numerical linear algebra are designed to minimize cache misses. Because of this chain, many modern CPUs try to guess what you will want next in your cache. When dealing with arrays, it will speculate ahead and grab what is known as a <em>cache line</em>: the next chunk in the array. Thus, your algorithms will be faster if you iterate along the values that it is grabbing.</p>
<p>The values that it grabs are the next values in the contiguous order of the stored array. There are two common conventions: row major and column major. Row major means that the linear array of memory is formed by stacking the rows one after another, while column major puts the column vectors one after another.</p>
<p><img src="https://eli.thegreenplace.net/images/2015/column-major-2D.png" alt="" /></p>
<p><em>Julia, MATLAB, and Fortran are column major</em>. Python&#39;s numpy is row-major.</p>


<pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_rows!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_rows!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
11.309 μs &#40;0 allocations: 0 bytes&#41;
</pre>



<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_cols!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_cols!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
6.940 μs &#40;0 allocations: 0 bytes&#41;
</pre>


<h3>Lower Level View: The Stack and the Heap</h3>
<p>Locally, the stack is composed of a <em>stack</em> and a <em>heap</em>. The stack requires a static allocation: it is ordered. Because it&#39;s ordered, it is very clear where things are in the stack, and therefore accesses are very quick &#40;think instantanious&#41;. However, because this is static, it requires that the size of the variables is known at compile time &#40;to determine all of the variable locations&#41;. Since that is not possible with all variables, there exists the heap. The heap is essentially a stack of pointers to objects in memory. When heap variables are needed, their values are pulled up the cache chain and accessed.</p>
<p><img src="https://bayanbox.ir/view/581244719208138556/virtual-memory.jpg" alt="" /> <img src="https://camo.githubusercontent.com/ca96d70d09ce694363e44b93fd975bb3033898c1/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6a6176612d6d656d6f72792d6d6f64656c2d352e706e67" alt="" /></p>
<h3>Heap Allocations and Speed</h3>
<p>Heap allocations are costly because they involve this pointer indirection, so stack allocation should be done when sensible &#40;it&#39;s not helpful for really large arrays, but for small values like scalars it&#39;s essential&#33;&#41;</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
221.044 μs &#40;10000 allocations: 937.50 KiB&#41;
</pre>



<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
6.940 μs &#40;0 allocations: 0 bytes&#41;
</pre>


<p>Why does the array here get heap-allocated? It isn&#39;t able to prove/guerentee at compile-time that the array&#39;s size will always be a given value, and thus it allocates it to the heap. <code>@btime</code> tells us this allocation occured and shows us the total heap memory that was taken. Meanwhile, the size of a Float64 number is known at compile-time &#40;64-bits&#41;, and so this is stored onto the stack and given a specific location that the compiler will be able to directly address.</p>
<p>Note that one can use the StaticArrays.jl library to get statically-sized arrays and thus arrays which are stack-allocated:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>StaticArrays</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>static_inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@SVector</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>static_inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
6.940 μs &#40;0 allocations: 0 bytes&#41;
</pre>


<h3>Mutation to Avoid Heap Allocations</h3>
<p>Many times you do need to write into an array, so how can you write into an array without performing a heap allocation? The answer is mutation. Mutation is changing the values of an already existing array. In that case, no free memory has to be found to put the array &#40;and no memory has to be freed by the garbage collector&#41;.</p>
<p>In Julia, functions which mutate the first value are conventionally noted by a <code>&#33;</code>. See the difference between these two equivalent functions:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
6.940 μs &#40;0 allocations: 0 bytes&#41;
</pre>



<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>similar</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
13.365 μs &#40;2 allocations: 78.20 KiB&#41;
</pre>


<p>To use this algorithm effectively, the <code>&#33;</code> algorithm assumes that the caller already has allocated the output array to put as the output argument. If that is not true, then one would need to manually allocate. The goal of that interface is to give the caller control over the allocations to allow them to manually reduce the total number of heap allocations and thus increase the speed.</p>
<h3>Julia&#39;s Broadcasting Mechanism</h3>
<p>Wouldn&#39;t it be nice to not have to write the loop there? In many high level languages this is simply called <em>vectorization</em>. In Julia, we will call it <em>array vectorization</em> to distinguish it from the <em>SIMD vectorization</em> which is common in lower level languages like C, Fortran, and Julia.</p>
<p>In Julia, if you use <code>.</code> on an operator it will transform it to the broadcasted form. Broadcast is <em>lazy</em>: it will build up an entire <code>.</code>&#39;d expression and then call <code>broadcast&#33;</code> on composed expression. This is customizable and <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting-1">documented in detail</a>. However, to a first approximation we can think of the broadcast mechanism as a mechanism for building <em>fused expressions</em>. For example, the Julia code:</p>


<pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-p'>;</span>
</pre>



<p>under the hood lowers to something like:</p>


<pre class='hljl'>
<span class='hljl-nf'>map</span><span class='hljl-p'>((</span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-oB'>-&gt;</span><span class='hljl-n'>a</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>+</span><span class='hljl-n'>c</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre>



<p>where <code>map</code> is a function that just loops over the values element-wise.</p>
<p><strong>Take a quick second to think about why loop fusion may be an optimization.</strong></p>
<p>This about what would happen if you did not fuse the operations. We can write that out as:</p>


<pre class='hljl'>
<span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'>
</span><span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-p'>;</span>
</pre>



<p>Notice that if we did not fuse the expressions, we would need some place to put the result of <code>A .&#43; B</code>, and that would have to be an array, which means it would cause a heap allocation. Thus broadcast fusion eliminates the <em>temporary variable</em> &#40;colloquially called just a <em>temporary</em>&#41;.</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>unfused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'>
  </span><span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>unfused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre>


<pre class="output">
15.936 μs &#40;4 allocations: 156.41 KiB&#41;
</pre>



<pre class='hljl'>
<span class='hljl-nf'>fused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>fused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre>


<pre class="output">
8.225 μs &#40;2 allocations: 78.20 KiB&#41;
</pre>


<p>Note that we can also fuse the output by using <code>.&#61;</code>. This is essentially the vectorized version of a <code>&#33;</code> function:</p>


<pre class='hljl'>
<span class='hljl-n'>D</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>similar</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>fused!</span><span class='hljl-p'>(</span><span class='hljl-n'>D</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>D</span><span class='hljl-t'> </span><span class='hljl-oB'>.=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>fused!</span><span class='hljl-p'>(</span><span class='hljl-n'>D</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre>


<pre class="output">
4.039 μs &#40;0 allocations: 0 bytes&#41;
</pre>


<h3>Note on Broadcasting Function Calls</h3>
<p>Julia allows for broadcasting the call <code>&#40;&#41;</code> operator as well. <code>.&#40;&#41;</code> will call the function element-wise on all arguments, so <code>sin.&#40;A&#41;</code> will be the elementwise sine function. This will fuse Julia like the other operators.</p>
<h3>Note on Vectorization and Speed</h3>
<p>In articles on MATLAB, Python, R, etc., this is where you will be told to vectorize your code. Notice from above that this isn&#39;t a performance difference between writing loops and using vectorized broadcasts. This is not abnormal&#33; The reason why you are told to vectorize code in these other languages is because they have a high per-operation overhead &#40;which will be discussed further down&#41;. This means that every call, like <code>&#43;</code>, is costly in these languages. To get around this issue and make the language usable, someone wrote and compiled the loop for the C/Fortran function that does the broadcasted form &#40;see numpy&#39;s Github repo&#41;. Thus <code>A .&#43; B</code>&#39;s MATLAB/Python/R equivalents are calling a single C function to generally avoid the cost of function calls and thus are faster.</p>
<p>But this is not an intrinsic property of vectorization. Vectorization isn&#39;t &quot;fast&quot; in these languages, it&#39;s just close to the correct speed. The reason vectorization is recommended is because looping is slow in these languages. Because looping isn&#39;t slow in Julia &#40;or C, C&#43;&#43;, Fortran, etc.&#41;, loops and vectorization generally have the same speed. So use the one that works best for your code without a care about performance.</p>
<p>&#40;As a small side effect, these high level languages tend to allocate a lot of temporary variables since the individual C kernels are written for specific numbers of inputs and thus don&#39;t naturally fuse. Julia&#39;s broadcast mechanism is just generating and JIT compiling Julia functions on the fly, and thus it can accomodate the combinatorial explosion in the amount of choices just by only compiling the combinations that are necessary for a specific code&#41;</p>
<h3>Heap Allocations from Slicing</h3>
<p>It&#39;s important to note that slices in Julia produce copies instead of views. Thus for example:</p>


<pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>50</span><span class='hljl-p'>,</span><span class='hljl-ni'>50</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
-1.0
</pre>


<p>allocates a new output. This is for safety, since if it pointed to the same array then writing to it would change the original array. We can demonstrate this by asking for a <em>view</em> instead of a copy.</p>


<pre class='hljl'>
<span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
A&#91;1&#93; &#61; -4.612714199668968e120
</pre>



<pre class='hljl'>
<span class='hljl-n'>E</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@view</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>5</span><span class='hljl-p'>,</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>5</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>E</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-t'>
</span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
A&#91;1&#93; &#61; 2.0
2.0
</pre>


<p>However, this means that <code>@view A&#91;1:5,1:5&#93;</code> did not allocate an array &#40;it does allocate a pointer if the escape analysis is unable to prove that it can be elided. This means that in small loops there will be no allocation, while if the view is returned from a function for example it will allocate the pointer, ~80 bytes, but not the memory of the array. This means that it is O&#40;1&#41; in cost but with a relatively small constant&#41;.</p>
<h3>Asymtopic Cost of Heap Allocations</h3>
<p>Heap allocations have to locate and prepare a space in RAM that is proportional to the amount of memory that is calcuated, which means that the cost of a heap allocation for an array is O&#40;n&#41;, with a large constant. As RAM begins to fill up, this cost dramatically increases. If you run out of RAM, your computer may begin to use <em>swap</em>, which is essentially RAM simulated on your hard drive. Generally when you hit swap your performance is so dead that you may think that your computation froze, but if you check your resource use you will notice that it&#39;s actually just filled the RAM and starting to use the swap.</p>
<p>But think of it as O&#40;n&#41; with a large constant factor. This means that for operations which only touch the data once, heap allocations can dominate the computational cost:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>LinearAlgebra</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.*</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>B</span><span class='hljl-t'>
    </span><span class='hljl-n'>t2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-oB'>$</span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>.=</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.*</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-p'>,</span><span class='hljl-n'>t2</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>ns</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>.^</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-oB'>:</span><span class='hljl-ni'>11</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>res</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>n</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>ns</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>alloc</span><span class='hljl-t'>   </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>noalloc</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>

</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Plots</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>alloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;=&quot;</span><span class='hljl-p'>,</span><span class='hljl-n'>xscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>yscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>legend</span><span class='hljl-oB'>=:</span><span class='hljl-n'>bottomright</span><span class='hljl-p'>,</span><span class='hljl-t'>
     </span><span class='hljl-n'>title</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Micro-optimizations matter for BLAS1&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>noalloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;.=&quot;</span><span class='hljl-p'>)</span>
</pre>


<img src="data:image/png;base64,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"  />

<p>However, when the computation takes O&#40;n^3&#41;, like in matrix multiplications, the high constant factor only comes into play when the matrices are sufficiently small:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>LinearAlgebra</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-oB'>*$</span><span class='hljl-n'>B</span><span class='hljl-t'>
    </span><span class='hljl-n'>t2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-nf'>mul!</span><span class='hljl-p'>(</span><span class='hljl-oB'>$</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-oB'>$</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-p'>,</span><span class='hljl-n'>t2</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>ns</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>.^</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-oB'>:</span><span class='hljl-ni'>7</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>res</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>n</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>ns</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>alloc</span><span class='hljl-t'>   </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>noalloc</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>

</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Plots</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>alloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;*&quot;</span><span class='hljl-p'>,</span><span class='hljl-n'>xscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>yscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>legend</span><span class='hljl-oB'>=:</span><span class='hljl-n'>bottomright</span><span class='hljl-p'>,</span><span class='hljl-t'>
     </span><span class='hljl-n'>title</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Micro-optimizations only matter for small matmuls&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>noalloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;mul!&quot;</span><span class='hljl-p'>)</span>
</pre>


<img src="data:image/png;base64,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"  />

<p>Though using a mutating form is never bad and always is a little bit better.</p>
<h3>Optimizing Memory Use Summary</h3>
<ul>
<li><p>Avoid cache misses by reusing values</p>
</li>
<li><p>Iterate along columns</p>
</li>
<li><p>Avoid heap allocations in inner loops</p>
</li>
<li><p>Heap allocations occur when the size of things is not proven at compile-time</p>
</li>
<li><p>Use fused broadcasts &#40;with mutated outputs&#41; to avoid heap allocations</p>
</li>
<li><p>Array vectorization confers no special benefit in Julia because Julia loops are as fast as C or Fortran</p>
</li>
<li><p>Use views instead of slices when applicable</p>
</li>
<li><p>Avoiding heap allocations is most necessary for O&#40;n&#41; algorithms or algorithms with small arrays</p>
</li>
<li><p>Use StaticArrays.jl to avoid heap allocations of small arrays in inner loops</p>
</li>
</ul>
<h2>Julia&#39;s Type Inference and the Compiler</h2>
<p>Many people think Julia is fast because it is JIT compiled. That is simply not true &#40;we&#39;ve already shown examples where Julia code isn&#39;t fast, but it&#39;s always JIT compiled&#33;&#41;. Instead, the reason why Julia is fast is because the combination of two ideas:</p>
<ul>
<li><p>Type inference</p>
</li>
<li><p>Type specialization in functions</p>
</li>
</ul>
<p>These two features naturally give rise to Julia&#39;s core design feature: multiple dispatch. Let&#39;s break down these pieces.</p>
<h3>Type Inference</h3>
<p>At the core level of the computer, everything has a type. Some languages are more explicit about said types, while others try to hide the types from the user. A type tells the compiler how to to store and interpret the memory of a value. For example, if the compiled code knows that the value in the register is supposed to be interpreted as a 64-bit floating point number, then it understands that slab of memory like:</p>
<p><img src="https://www.google.com/url?sa&#61;i&amp;source&#61;images&amp;cd&#61;&amp;ved&#61;2ahUKEwjVnMqWkrbkAhVmRN8KHUAJCC0QjRx6BAgBEAQ&amp;url&#61;https&#37;3A&#37;2F&#37;2Fstackoverflow.com&#37;2Fquestions&#37;2F5113005&#37;2Fquestion-regarding-ieee-754-64-bits-double&amp;psig&#61;AOvVaw3oZeV3nq-TYI8pDPzaRZ1_&amp;ust&#61;1567651252167050" alt="" /></p>
<p>Importantly, it will know what to do for function calls. If the code tells it to add two floating point numbers, it will send them as inputs to the Floating Point Unit &#40;FPU&#41; which will give the output.</p>
<p>If the types are not known, then... ? So one cannot actually compute until the types are known, since otherwise it&#39;s impossible to interpret the memory. In languages like C, the programmer has to declare the types of variables in the program:</p>
<pre><code>void add&#40;double *a, double *b, double *c, size_t n&#41;&#123;
  size_t i;
  for&#40;i &#61; 0; i &lt; n; &#43;&#43;i&#41; &#123;
    c&#91;i&#93; &#61; a&#91;i&#93; &#43; b&#91;i&#93;;
  &#125;
&#125;</code></pre>
<p>The types are known at compile time because the programmer set it in stone. In many interpreted languages Python, types are checked at runtime. For example,</p>
<pre><code>a &#61; 2
b &#61; 4
a &#43; b</code></pre>
<p>when the addition occurs, the Python interpreter will check the object holding the values and ask it for its types, and use those types to know how to compute the &#43; function. For this reason, the add function in Python is rather complex since it needs to decode and have a version for all primative types&#33;</p>
<p>Not only is there runtime overhead checks in function calls due to to not being explicit about types, there is also a memory overhead since it is impossible to know how much memory a value with take since that&#39;s a property of its type. Thus the Python interpreter cannot statically guerentee exact unchanging values for the size that a value would take in the stack, meaning that the variables are not stack-allocated. This means that every number ends up heap-allocated, which hopefully begins to explain why this is not as fast as C.</p>
<p>The solution is Julia is somewhat of a hybrid. The Julia code looks like:</p>


<pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span>
</pre>


<pre class="output">
6
</pre>


<p>However, before JIT compilation, Julia runs a type inference algorithm which finds out that <code>A</code> is an <code>Int</code>, and <code>B</code> is an <code>Int</code>. You can then understand that if it can prove that <code>A&#43;B</code> is an <code>Int</code>, then it can propogate all of the types through.</p>
<h3>Type Specialization in Functions</h3>
<p>Julia is able to propogate type inference through functions because, even if a function is &quot;untyped&quot;, Julia will interpret this as a <em>generic function</em> over possible <em>methods</em>, where every method has a concrete type. This means that in Julia, the function:</p>


<pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>+</span><span class='hljl-n'>y</span>
</pre>


<pre class="output">
f &#40;generic function with 1 method&#41;
</pre>


<p>is not what you may think of as a &quot;single function&quot;, since given inputs of different types it will actually be a different function. We can see this by examining the <em>LLVM IR</em> &#40;LLVM is Julia&#39;s compiler, the IR is the <em>Intermediate Representation</em>, i.e. a platform-independent representation of assembly that lives in LLVM that it knows how to convert into assembly per architecture&#41;:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>InteractiveUtils</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:1 within &#96;f&#39;
; Function Attrs: uwtable
define i64 @julia_f_22409&#40;i64, i64&#41; #0 &#123;
top:
; ┌ @ int.jl:53 within &#96;&#43;&#39;
   &#37;2 &#61; add i64 &#37;1, &#37;0
; └
  ret i64 &#37;2
&#125;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>5.0</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:1 within &#96;f&#39;
; Function Attrs: uwtable
define double @julia_f_22410&#40;double, double&#41; #0 &#123;
top:
; ┌ @ float.jl:395 within &#96;&#43;&#39;
   &#37;2 &#61; fadd double &#37;0, &#37;1
; └
  ret double &#37;2
&#125;
</pre>


<p>Notice that when <code>f</code> is the function that takes in two <code>Int</code>s, <code>Int</code>s add to give an <code>Int</code> and thus <code>f</code> outputs an <code>Int</code>. When <code>f</code> is the function that takes two <code>Float64</code>s, <code>f</code> returns a <code>Float64</code>. Thus in the code:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;g&#39;
; Function Attrs: uwtable
define i64 @julia_g_22411&#40;i64, i64&#41; #0 &#123;
top:
;  @ none:5 within &#96;g&#39;
; ┌ @ none:1 within &#96;f&#39;
; │┌ @ int.jl:53 within &#96;&#43;&#39;
    &#37;2 &#61; add i64 &#37;0, 6
; └└
;  @ none:6 within &#96;g&#39;
; ┌ @ none:1 within &#96;f&#39;
; │┌ @ int.jl:53 within &#96;&#43;&#39;
    &#37;3 &#61; add i64 &#37;2, &#37;1
; └└
  ret i64 &#37;3
&#125;
</pre>


<p><code>g</code> on two <code>Int</code> inputs is a function that has <code>Int</code>s at every step along the way and spits out an <code>Int</code>. We can use the <code>@code_warntype</code> macro to better see the inference along the steps of the function:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
Body::Int64
1 ─ &#37;1 &#61; π &#40;4, Core.Compiler.Const&#40;4, false&#41;&#41;
│   &#37;2 &#61; &#40;Base.add_int&#41;&#40;x, &#37;1&#41;::Int64
│   &#37;3 &#61; π &#40;2, Core.Compiler.Const&#40;2, false&#41;&#41;
│   &#37;4 &#61; &#40;Base.add_int&#41;&#40;&#37;3, &#37;2&#41;::Int64
│   &#37;5 &#61; &#40;Base.add_int&#41;&#40;&#37;4, y&#41;::Int64
└──      return &#37;5
</pre>


<p>What happens on mixtures?</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:1 within &#96;f&#39;
; Function Attrs: uwtable
define double @julia_f_22412&#40;double, i64&#41; #0 &#123;
top:
; ┌ @ promotion.jl:313 within &#96;&#43;&#39;
; │┌ @ promotion.jl:284 within &#96;promote&#39;
; ││┌ @ promotion.jl:261 within &#96;_promote&#39;
; │││┌ @ number.jl:7 within &#96;convert&#39;
; ││││┌ @ float.jl:60 within &#96;Type&#39;
       &#37;2 &#61; sitofp i64 &#37;1 to double
; │└└└└
; │ @ promotion.jl:313 within &#96;&#43;&#39; @ float.jl:395
   &#37;3 &#61; fadd double &#37;2, &#37;0
; └
  ret double &#37;3
&#125;
</pre>


<p>When we add an <code>Int</code> to a <code>Float64</code>, we promote the <code>Int</code> to a <code>Float64</code> and then perform the <code>&#43;</code> between two <code>Float64</code>s. When we go to the full function, we see that it can still infer:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
Body::Float64
1 ─ &#37;1 &#61; &#40;Base.add_float&#41;&#40;x, 4.0&#41;::Float64
│   &#37;2 &#61; &#40;Base.add_float&#41;&#40;2.0, &#37;1&#41;::Float64
│   &#37;3 &#61; &#40;Base.sitofp&#41;&#40;Float64, y&#41;::Float64
│   &#37;4 &#61; &#40;Base.add_float&#41;&#40;&#37;2, &#37;3&#41;::Float64
└──      return &#37;4
</pre>


<p>and it uses this to build a very efficient assembly code because it knows exactly what the types will be at every step:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;g&#39;
; Function Attrs: uwtable
define double @julia_g_22413&#40;double, i64&#41; #0 &#123;
top:
;  @ none:4 within &#96;g&#39;
; ┌ @ none:1 within &#96;f&#39;
; │┌ @ promotion.jl:313 within &#96;&#43;&#39; @ float.jl:395
    &#37;2 &#61; fadd double &#37;0, 4.000000e&#43;00
; └└
;  @ none:5 within &#96;g&#39;
; ┌ @ none:1 within &#96;f&#39;
; │┌ @ promotion.jl:313 within &#96;&#43;&#39; @ float.jl:395
    &#37;3 &#61; fadd double &#37;2, 2.000000e&#43;00
; └└
;  @ none:6 within &#96;g&#39;
; ┌ @ none:1 within &#96;f&#39;
; │┌ @ promotion.jl:313 within &#96;&#43;&#39;
; ││┌ @ promotion.jl:284 within &#96;promote&#39;
; │││┌ @ promotion.jl:261 within &#96;_promote&#39;
; ││││┌ @ number.jl:7 within &#96;convert&#39;
; │││││┌ @ float.jl:60 within &#96;Type&#39;
        &#37;4 &#61; sitofp i64 &#37;1 to double
; ││└└└└
; ││ @ promotion.jl:313 within &#96;&#43;&#39; @ float.jl:395
    &#37;5 &#61; fadd double &#37;3, &#37;4
; └└
  ret double &#37;5
&#125;
</pre>


<p>&#40;notice how it handles the constant <em>literals</em> 4 and 2: it converted them at compile time to reduce the algorithm to 3 floating point additions&#41;.</p>
<h3>Type Stability</h3>
<p>Why is the inference algorithm able to infer all of the types of <code>g</code>? It&#39;s because it knows the types coming out of <code>f</code> at compile time. Given an <code>Int</code> and a <code>Float64</code>, <code>f</code> will always output a <code>Float64</code>, and thus it can continue with inference knowing that <code>c</code>, <code>d</code>, and eventually the output is <code>Float64</code>. Thus in order for this to occur, we need that the type of the output on our function is directly inferred from the type of the input. This property is known as type-stability.</p>
<p>An example of breaking it is as follows:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>h</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>out</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
  </span><span class='hljl-nf'>rand</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>&lt;</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.5</span><span class='hljl-t'> </span><span class='hljl-oB'>?</span><span class='hljl-t'> </span><span class='hljl-n'>out</span><span class='hljl-t'> </span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-nf'>Float64</span><span class='hljl-p'>(</span><span class='hljl-n'>out</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="output">
h &#40;generic function with 1 method&#41;
</pre>


<p>Here, on an integer input the output&#39;s type is randomly either Int or Float64, and thus the output is unknown:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>h</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
Body::UNION&#123;FLOAT64, INT64&#125;
1 ── &#37;1  &#61; &#40;Base.add_int&#41;&#40;x, y&#41;::Int64
│    &#37;2  &#61; Random.GLOBAL_RNG::Random.MersenneTwister
│    &#37;3  &#61; &#40;Base.getfield&#41;&#40;&#37;2, :idxF&#41;::Int64
│    &#37;4  &#61; Random.MT_CACHE_F::Int64
│    &#37;5  &#61; &#40;&#37;3 &#61;&#61;&#61; &#37;4&#41;::Bool
└───       goto #3 if not &#37;5
2 ── &#37;7  &#61; &#36;&#40;Expr&#40;:gc_preserve_begin, :&#40;&#37;2&#41;&#41;&#41;
│    &#37;8  &#61; &#40;Base.getfield&#41;&#40;&#37;2, :state&#41;::Random.DSFMT.DSFMT_state
│    &#37;9  &#61; &#40;Base.getfield&#41;&#40;&#37;2, :vals&#41;::Array&#123;Float64,1&#125;
│    &#37;10 &#61; &#36;&#40;Expr&#40;:foreigncall, :&#40;:jl_array_ptr&#41;, Ptr&#123;Float64&#125;, svec&#40;Any&#41;, 
:&#40;:ccall&#41;, 1, :&#40;&#37;9&#41;&#41;&#41;::Ptr&#123;Float64&#125;
│    &#37;11 &#61; &#40;Base.getfield&#41;&#40;&#37;2, :vals&#41;::Array&#123;Float64,1&#125;
│    &#37;12 &#61; &#40;Base.arraylen&#41;&#40;&#37;11&#41;::Int64
│          invoke Random.dsfmt_fill_array_close1_open2&#33;&#40;&#37;8::Random.DSFMT.DS
FMT_state, &#37;10::Ptr&#123;Float64&#125;, &#37;12::Int64&#41;
│          &#36;&#40;Expr&#40;:gc_preserve_end, :&#40;&#37;7&#41;&#41;&#41;
└───       &#40;Base.setfield&#33;&#41;&#40;&#37;2, :idxF, 0&#41;
3 ┄─       goto #4
4 ── &#37;17 &#61; &#40;Base.getfield&#41;&#40;&#37;2, :vals&#41;::Array&#123;Float64,1&#125;
│    &#37;18 &#61; &#40;Base.getfield&#41;&#40;&#37;2, :idxF&#41;::Int64
│    &#37;19 &#61; &#40;Base.add_int&#41;&#40;&#37;18, 1&#41;::Int64
│          &#40;Base.setfield&#33;&#41;&#40;&#37;2, :idxF, &#37;19&#41;
│    &#37;21 &#61; &#40;Base.arrayref&#41;&#40;false, &#37;17, &#37;19&#41;::Float64
└───       goto #5
5 ──       goto #6
6 ── &#37;24 &#61; &#40;Base.sub_float&#41;&#40;&#37;21, 1.0&#41;::Float64
└───       goto #7
7 ──       goto #8
8 ──       goto #9
9 ── &#37;28 &#61; &#40;Base.lt_float&#41;&#40;&#37;24, 0.5&#41;::Bool
└───       goto #11 if not &#37;28
10 ─       return &#37;1
11 ─ &#37;31 &#61; &#40;Base.sitofp&#41;&#40;Float64, &#37;1&#41;::Float64
└───       return &#37;31
</pre>


<p>This means that its output type is <code>Union&#123;Int,Float64&#125;</code> &#40;Julia uses union types to keep the types still somewhat constrained&#41;. Once there are multiple choices, those need to get propogated through the compiler, and all subsequent calculations are the result of either being an <code>Int</code> or a <code>Float64</code>.</p>
<p>&#40;Note that Julia has small union optimizations, so if this union is of size 4 or less then Julia will still be able to optimize it quite a bit.&#41;</p>
<h3>Multiple Dispatch</h3>
<p>The <code>&#43;</code> function on numbers was implemented in Julia, so how were these rules all written down? The answer is multiple dispatch. In Julia, you can tell a function how to act differently on different types by using type assertions on the input values. For example, let&#39;s make a function that computes <code>2x &#43; y</code> on <code>Int</code> and <code>x/y</code> on <code>Float64</code>:</p>


<pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>/</span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
ff&#40;2, 5&#41; &#61; 9
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>5.0</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
ff&#40;2.0, 5.0&#41; &#61; 0.4
0.4
</pre>


<p>The <code>&#43;</code> function in Julia is just defined as <code>&#43;&#40;a,b&#41;</code>, and we can actually point to that code in the Julia distribution:</p>


<pre class='hljl'>
<span class='hljl-nd'>@which</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>



+(x::<b>Number</b>, y::<b>Number</b>) in Base at <a href="https://github.com/JuliaLang/julia/tree/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/promotion.jl#L313" target="_blank">promotion.jl:313</a>

<p>To control at a higher level, Julia uses <em>abstract types</em>. For example, <code>Float64 &lt;: AbstractFloat</code>, meaning <code>Float64</code>s are a subtype of <code>AbstractFloat</code>. We also have that <code>Int &lt;: Integer</code>, while both <code>AbstractFloat &lt;: Number</code> and <code>Integer &lt;: Number</code>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/Type-hierarchy-for-julia-numbers.png/800px-Type-hierarchy-for-julia-numbers.png" alt="" /></p>
<p>Julia allows the user to define dispatches at a higher level, and the version that is called is the most strict version that is correct. For example, right now with <code>ff</code> we will get a <code>MethodError</code> if we call it between a <code>Int</code> and a <code>Float64</code> because no such method exists:</p>


<pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: MethodError: no method matching ff&#40;::Float64, ::Int64&#41;
Closest candidates are:
  ff&#40;::Float64, &#33;Matched::Float64&#41; at none:1
  ff&#40;&#33;Matched::Int64, ::Int64&#41; at none:1
</pre>


<p>However, we can add a <em>fallback method</em> to the function <code>ff</code> for two numbers:</p>


<pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
7.0
</pre>


<p>Notice that the fallback method still specailizes on the inputs:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:1 within &#96;ff&#39;
; Function Attrs: uwtable
define double @julia_ff_22420&#40;double, i64&#41; #0 &#123;
top:
; ┌ @ promotion.jl:313 within &#96;&#43;&#39;
; │┌ @ promotion.jl:284 within &#96;promote&#39;
; ││┌ @ promotion.jl:261 within &#96;_promote&#39;
; │││┌ @ number.jl:7 within &#96;convert&#39;
; ││││┌ @ float.jl:60 within &#96;Type&#39;
       &#37;2 &#61; sitofp i64 &#37;1 to double
; │└└└└
; │ @ promotion.jl:313 within &#96;&#43;&#39; @ float.jl:395
   &#37;3 &#61; fadd double &#37;2, &#37;0
; └
  ret double &#37;3
&#125;
</pre>


<p>It&#39;s essentially just a template for what functions to possibly try and create given the types that are seen. When it sees <code>Float64</code> and <code>Int</code>, it knows it should try and create the function that does <code>x&#43;y</code>, and once it knows it&#39;s <code>Float64</code> plus a <code>Int</code>, it knows it should create the function that converts the <code>Int</code> to a <code>Float64</code> and then does addition between two <code>Float64</code>s, and that is precisely the generated LLVM IR on this pair of input types.</p>
<p>And that&#39;s essentially Julia&#39;s secret sauce: since it&#39;s always specializing its types on each function, if those functions themselves can infer the output, then the entire function can be inferred and generate optimal code, which is then optimized by the compiler and out comes an efficient function. If types can&#39;t be inferred, Julia falls back to a slower &quot;Python&quot; mode &#40;though with optimizations in cases like small unions&#41;. Users then get control over this specialization process through multiple dispatch, which is then Julia&#39;s core feature since it allows adding new options without any runtime cost.</p>
<h3>Any Fallbacks</h3>
<p>Note that <code>f&#40;x,y&#41; &#61; x&#43;y</code> is equivalent to <code>f&#40;x::Any,y::Any&#41; &#61; x&#43;y</code>, where <code>Any</code> is the maximal supertype of every Julia type. Thus <code>f&#40;x,y&#41; &#61; x&#43;y</code> is essentially a fallback for all possible input values, telling it what to do in the case that no other dispatches exist. However, note that this dispatch itself is not slow, since it will be specailized on the input types.</p>
<h3>Ambiguities</h3>
<p>The version that is called is the most strict version that is correct. What happens if it&#39;s impossible to define &quot;the most strict version&quot;? For example,</p>


<pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>5</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>y</span>
</pre>


<pre class="output">
ff &#40;generic function with 5 methods&#41;
</pre>


<p>What should it call on <code>f&#40;2.0,5&#41;</code> now?  <code>ff&#40;x::Float64,y::Number&#41;</code> and <code>ff&#40;x::Number,y::Int&#41;</code> are both more strict than <code>ff&#40;x::Number,y::Number&#41;</code>, so one of them should be called, but neither are more strict than each other, and thus you will end up with an ambiguity error:</p>


<pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="julia-error">
ERROR: MethodError: Main.WeaveSandBox4.ff&#40;::Float64, ::Int64&#41; is ambiguous. Candidates:
  ff&#40;x::Number, y::Int64&#41; in Main.WeaveSandBox4 at none:1
  ff&#40;x::Float64, y::Number&#41; in Main.WeaveSandBox4 at none:1
Possible fix, define
  ff&#40;::Float64, ::Int64&#41;
</pre>


<h3>Untyped Containers</h3>
<p>One way to ruin inference is to use an untyped container. For example, the array constructors use type inference themselves to know what their container type will be. Therefore,</p>


<pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>3.0</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
3-element Array&#123;Float64,1&#125;:
 1.0
 2.0
 3.0
</pre>


<p>uses type inference on its inputs to know that it should be something that holds <code>Float64</code> values, and thus it is a 1-dimensional array of <code>Float64</code> values, or <code>Array&#123;Float64,1&#125;</code>. The accesses:</p>


<pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
1.0
</pre>


<p>are then inferred, since this is just the function <code>getindex&#40;a::Array&#123;T&#125;,i&#41; where T</code> which is a function that will produce something of type <code>T</code>, the element type of the array. However, if we tell Julia to make an array with element type <code>Any</code>:</p>


<pre class='hljl'>
<span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-s'>&quot;1.0&quot;</span><span class='hljl-p'>,</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>]</span>
</pre>


<pre class="output">
3-element Array&#123;Any,1&#125;:
  &quot;1.0&quot;
 2     
 2.0
</pre>


<p>&#40;here, Julia falls back to <code>Any</code> because it cannot promote the values to the same type&#41;, then the best inference can do on the output is to say it could have any type:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>bad_container</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>bad_container</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
Body::Float64
1 ─ &#37;1 &#61; &#40;Base.arrayref&#41;&#40;true, a, 2&#41;::Float64
└──      return &#37;1
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>bad_container</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
Body::ANY
1 ─ &#37;1 &#61; &#40;Base.arrayref&#41;&#40;true, a, 2&#41;::ANY
└──      return &#37;1
</pre>


<p>This is one common way that type inference can breakdown. For example, even if the array is all numbers, we can still break inference:</p>


<pre class='hljl'>
<span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Number</span><span class='hljl-p'>[</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>3</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>q</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>q</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
Body::ANY
1 ─ &#37;1 &#61; &#40;Base.arrayref&#41;&#40;true, x, 1&#41;::NUMBER
│   &#37;2 &#61; π &#40;4, Core.Compiler.Const&#40;4, false&#41;&#41;
│   &#37;3 &#61; &#40;Main.WeaveSandBox4.f&#41;&#40;&#37;1, &#37;2&#41;::ANY
│   &#37;4 &#61; π &#40;2, Core.Compiler.Const&#40;2, false&#41;&#41;
│   &#37;5 &#61; &#40;Main.WeaveSandBox4.f&#41;&#40;&#37;4, &#37;3&#41;::ANY
│   &#37;6 &#61; &#40;Base.arrayref&#41;&#40;true, x, 2&#41;::NUMBER
│   &#37;7 &#61; &#40;Main.WeaveSandBox4.f&#41;&#40;&#37;5, &#37;6&#41;::ANY
└──      return &#37;7
</pre>


<p>Here the type inference algorithm quickly gives up and infers to <code>Any</code>, losing all specialization and automatically switching to Python-style runtime type checking.</p>
<h3>Function Barriers</h3>
<p>Since functions automatically specialize on their input types in Julia, we can use this to our advantage in order to make an inner loop fully inferred. For example, take the code from above but with a loop:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>r</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>r</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
5.826 μs &#40;300 allocations: 4.69 KiB&#41;
604.0
</pre>


<p>In here, the loop variables are not inferred and thus this is really slow. However, we can force a function call in the middle to end up with specialization and in the inner loop be stable:</p>


<pre class='hljl'>
<span class='hljl-nf'>s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>_s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>_s</span><span class='hljl-p'>(</span><span class='hljl-n'>x1</span><span class='hljl-p'>,</span><span class='hljl-n'>x2</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x1</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>x2</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
331.126 ns &#40;1 allocation: 16 bytes&#41;
604.0
</pre>


<p>Notice that this algorithm still doesn&#39;t infer:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
Body::ANY
1 ─ &#37;1 &#61; &#40;Base.arrayref&#41;&#40;true, x, 1&#41;::NUMBER
│   &#37;2 &#61; &#40;Base.arrayref&#41;&#40;true, x, 2&#41;::NUMBER
│   &#37;3 &#61; &#40;Main.WeaveSandBox4._s&#41;&#40;&#37;1, &#37;2&#41;::ANY
└──      return &#37;3
</pre>


<p>since the output of <code>_s</code> isn&#39;t inferred, but while it&#39;s in <code>_s</code> it will have specialized on the fact that <code>x&#91;1&#93;</code> is a <code>Float64</code> while <code>x&#91;2&#93;</code> is a <code>Int</code>, making that inner loop fast. In fact, it will only need to pay one <em>dynamic dispatch</em>, i.e. a multiple dispatch determination that happens at runtime. Notice that whenever functions are inferred, the dispatching is static since the choice of the dispatch is already made and compiled into the LLVM IR.</p>
<h3>Specialization at Compile Time</h3>
<p>Julia code will specialize at compile time if it can prove something about the result. For example:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>fff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-n'>isa</span><span class='hljl-t'> </span><span class='hljl-n'>Int</span><span class='hljl-t'>
    </span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-k'>else</span><span class='hljl-t'>
    </span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>4.0</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="output">
fff &#40;generic function with 1 method&#41;
</pre>


<p>You might think this function has a branch, but in reality Julia can determine whether <code>x</code> is an <code>Int</code> or not at compile time, so it will actually compile it away and just turn it into the function <code>x&#43;2</code> or <code>x&#43;4.0</code>:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>fff</span><span class='hljl-p'>(</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;fff&#39;
; Function Attrs: uwtable
define i64 @julia_fff_22458&#40;i64&#41; #0 &#123;
top:
;  @ none:7 within &#96;fff&#39;
; ┌ @ int.jl:53 within &#96;&#43;&#39;
   &#37;1 &#61; add i64 &#37;0, 2
; └
  ret i64 &#37;1
&#125;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>fff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;fff&#39;
; Function Attrs: uwtable
define double @julia_fff_22459&#40;double&#41; #0 &#123;
top:
;  @ none:7 within &#96;fff&#39;
; ┌ @ float.jl:395 within &#96;&#43;&#39;
   &#37;1 &#61; fadd double &#37;0, 4.000000e&#43;00
; └
  ret double &#37;1
&#125;
</pre>


<p>Thus one does not need to worry about over-optimizing since in the obvious cases the compiler will actually remove all of the extra pieces when it can&#33;</p>
<h3>Global Scope and Optimizations</h3>
<p>This discussion shows how Julia&#39;s optimizations all apply during function specialization times. Thus calling Julia functions is fast. But what about when doing something outside of the function, like directly in a module or in the REPL?</p>


<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-t'>
  </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="output">
829.173 μs &#40;30000 allocations: 468.75 KiB&#41;
</pre>


<p>This is very slow because the types of <code>A</code>, <code>B</code>, and <code>C</code> cannot be inferred. Why can&#39;t they be inferred? Well, at any time in the dynamic REPL scope I can do something like <code>C &#61; &quot;haha now a string&#33;&quot;</code>, and thus it cannot specialize on the types currently existing in the REPL &#40;since asynchronous changes could also occur&#41;, and therefore it defaults back to doing a type check at every single function which slows it down. Moral of the story, Julia functions are fast but its global scope is too dynamic to be optimized.</p>
<h3>Summary</h3>
<ul>
<li><p>Julia is not fast because of its JIT, it&#39;s fast because of function specialization and type inference</p>
</li>
<li><p>Type stable functions allow inference to fully occur</p>
</li>
<li><p>Multiple dispatch works within the function specialization mechanism to create overhead-free compile time controls</p>
</li>
<li><p>Julia will specialize the generic functions</p>
</li>
<li><p>Making sure values are concretely typed in inner loops is essential for performance</p>
</li>
</ul>
<h2>Overheads of Individual Operations</h2>
<p>Now let&#39;s dig even a little deeper. Everything the processor does has a cost. A great chart to keep in mind is <a href="http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/">this classic one</a>. A few things should immediately jump out to you:</p>
<ul>
<li><p>Simple arithmetic, like floating point additions, are super cheap. ~1 clock cycle, or a few nanoseconds.</p>
</li>
<li><p>Processors do <em>branch prediction</em> on <code>if</code> statements. If the code goes down the predicted route, the <code>if</code> statement costs ~1-2 clock cycles. If it goes down the wrong route, then it will take ~10-20 clock cycles. This means that predictable branches, like ones with clear patterns or usually the same output, are much cheaper &#40;almost free&#41; than unpredictable branches.</p>
</li>
<li><p>Function calls are expensive: 15-60 clock cycles&#33;</p>
</li>
<li><p>RAM reads are very expensive, with lower caches less expensive.</p>
</li>
</ul>
<h3>Bounds Checking</h3>
<p>Let&#39;s check the LLVM IR on one of our earlier loops:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;inner_noalloc&#33;&#39;
; Function Attrs: uwtable
define nonnull &#37;jl_value_t addrspace&#40;10&#41;* @&quot;japi1_inner_noalloc&#33;_22474&quot;&#40;&#37;jl
_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;**, i32&#41; #0 &#123;
top:
  &#37;3 &#61; alloca &#37;jl_value_t addrspace&#40;10&#41;**, align 8
  store volatile &#37;jl_value_t addrspace&#40;10&#41;** &#37;1, &#37;jl_value_t addrspace&#40;10&#41;*
** &#37;3, align 8
  &#37;4 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrs
pace&#40;10&#41;** &#37;1, i64 1
  &#37;5 &#61; load &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;** &#37;4, ali
gn 8
;  @ none:3 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:730 within &#96;getindex&#39;
   &#37;6 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;5 to &#37;jl_value_t addrspac
e&#40;11&#41;*
   &#37;7 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;6 to &#37;jl_value_t addrspace&#40;10&#41;*
 addrspace&#40;11&#41;*
   &#37;8 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addr
space&#40;10&#41;* addrspace&#40;11&#41;* &#37;7, i64 3
   &#37;9 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;8 to i64 addrspa
ce&#40;11&#41;*
   &#37;10 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;9, align 8
   &#37;11 &#61; icmp eq i64 &#37;10, 0
   br i1 &#37;11, label &#37;oob, label &#37;ib.lr.ph.lr.ph.split.us

ib.lr.ph.lr.ph.split.us:                          ; preds &#61; &#37;top
   &#37;12 &#61; load &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;** &#37;1, a
lign 8
   &#37;13 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t add
rspace&#40;10&#41;** &#37;1, i64 2
   &#37;14 &#61; load &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;** &#37;13, 
align 8
   &#37;15 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t add
rspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;7, i64 4
   &#37;16 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;15 to i64 addrs
pace&#40;11&#41;*
   &#37;17 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;16, align 8
   &#37;18 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;6 to double addrspace&#40;13&#41;* add
rspace&#40;11&#41;*
   &#37;19 &#61; load double addrspace&#40;13&#41;*, double addrspace&#40;13&#41;* addrspace&#40;11&#41;* &#37;
18, align 8
   &#37;20 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;14 to &#37;jl_value_t addrsp
ace&#40;11&#41;*
   &#37;21 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;20 to &#37;jl_value_t addrspace&#40;10
&#41;* addrspace&#40;11&#41;*
   &#37;22 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t add
rspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;21, i64 3
   &#37;23 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;22 to i64 addrs
pace&#40;11&#41;*
   &#37;24 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;23, align 8
   &#37;25 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t add
rspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;21, i64 4
   &#37;26 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;25 to i64 addrs
pace&#40;11&#41;*
   &#37;27 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;26, align 8
   &#37;28 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;20 to double addrspace&#40;13&#41;* ad
drspace&#40;11&#41;*
   &#37;29 &#61; load double addrspace&#40;13&#41;*, double addrspace&#40;13&#41;* addrspace&#40;11&#41;* &#37;
28, align 8
   &#37;30 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;12 to &#37;jl_value_t addrsp
ace&#40;11&#41;*
   &#37;31 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;30 to &#37;jl_value_t addrspace&#40;10
&#41;* addrspace&#40;11&#41;*
   &#37;32 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t add
rspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;31, i64 3
   &#37;33 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;32 to i64 addrs
pace&#40;11&#41;*
   &#37;34 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;33, align 8
   &#37;35 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t add
rspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;31, i64 4
   &#37;36 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;35 to i64 addrs
pace&#40;11&#41;*
   &#37;37 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;36, align 8
   &#37;38 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;30 to double addrspace&#40;13&#41;* ad
drspace&#40;11&#41;*
   &#37;39 &#61; load double addrspace&#40;13&#41;*, double addrspace&#40;13&#41;* addrspace&#40;11&#41;* &#37;
38, align 8
   br label &#37;ib.lr.ph.us

ib.lr.ph.us:                                      ; preds &#61; &#37;L35.us, &#37;ib.lr
.ph.lr.ph.split.us
   &#37;value_phi30.us &#61; phi i64 &#91; 1, &#37;ib.lr.ph.lr.ph.split.us &#93;, &#91; &#37;44, &#37;L35.u
s &#93;
   &#37;40 &#61; add i64 &#37;value_phi30.us, -1
   &#37;41 &#61; icmp ult i64 &#37;40, &#37;17
   &#37;42 &#61; icmp ult i64 &#37;40, &#37;37
   br i1 &#37;41, label &#37;ib.lr.ph.split.us.us, label &#37;oob

L25.us:                                           ; preds &#61; &#37;idxend9.us.us.
us.us
; └
;  @ none:4 within &#96;inner_noalloc&#33;&#39;
; ┌ @ range.jl:594 within &#96;iterate&#39;
; │┌ @ promotion.jl:403 within &#96;&#61;&#61;&#39;
    &#37;43 &#61; icmp eq i64 &#37;value_phi30.us, 100
; └└
  br i1 &#37;43, label &#37;L36, label &#37;L35.us

L35.us:                                           ; preds &#61; &#37;L25.us
; ┌ @ range.jl:595 within &#96;iterate&#39;
; │┌ @ int.jl:53 within &#96;&#43;&#39;
    &#37;44 &#61; add i64 &#37;value_phi30.us, 1
; └└
;  @ none:3 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:730 within &#96;getindex&#39;
   br label &#37;ib.lr.ph.us

ib.lr.ph.split.us.us:                             ; preds &#61; &#37;ib.lr.ph.us
   &#37;45 &#61; icmp ult i64 &#37;40, &#37;27
   br i1 &#37;45, label &#37;ib.lr.ph.split.us.split.us.us, label &#37;oob5

idxend.us.us.us:                                  ; preds &#61; &#37;ib.lr.ph.split
.us.split.us.us
   &#37;46 &#61; icmp eq i64 &#37;24, 0
   br i1 &#37;46, label &#37;oob5, label &#37;oob8

ib.lr.ph.split.us.split.us.us:                    ; preds &#61; &#37;ib.lr.ph.split
.us.us
   br i1 &#37;42, label &#37;ib.lr.ph.split.us.split.us.us.split.us, label &#37;idxend.
us.us.us

ib.lr.ph.split.us.split.us.us.split.us:           ; preds &#61; &#37;ib.lr.ph.split
.us.split.us.us
   &#37;47 &#61; mul i64 &#37;24, &#37;40
   &#37;48 &#61; mul i64 &#37;34, &#37;40
   br label &#37;idxend.us.us.us.us

idxend.us.us.us.us:                               ; preds &#61; &#37;ib.lr.ph.split
.us.split.us.us.split.us, &#37;L24.us.us.us.us
   &#37;49 &#61; phi i64 &#91; 0, &#37;ib.lr.ph.split.us.split.us.us.split.us &#93;, &#91; &#37;value_p
hi224.us.us.us.us, &#37;L24.us.us.us.us &#93;
   &#37;value_phi224.us.us.us.us &#61; phi i64 &#91; 1, &#37;ib.lr.ph.split.us.split.us.us.
split.us &#93;, &#91; &#37;63, &#37;L24.us.us.us.us &#93;
   &#37;50 &#61; icmp ult i64 &#37;49, &#37;24
   br i1 &#37;50, label &#37;idxend6.us.us.us.us, label &#37;oob5

idxend6.us.us.us.us:                              ; preds &#61; &#37;idxend.us.us.u
s.us
; └
;  @ none:4 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:769 within &#96;setindex&#33;&#39;
   &#37;51 &#61; icmp ult i64 &#37;49, &#37;34
   br i1 &#37;51, label &#37;idxend9.us.us.us.us, label &#37;oob8

idxend9.us.us.us.us:                              ; preds &#61; &#37;idxend6.us.us.
us.us
; └
;  @ none:3 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:730 within &#96;getindex&#39;
   &#37;52 &#61; mul i64 &#37;10, &#37;40
   &#37;53 &#61; add i64 &#37;49, &#37;52
   &#37;54 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;19, i64 &#37;53
   &#37;55 &#61; load double, double addrspace&#40;13&#41;* &#37;54, align 8
   &#37;56 &#61; add i64 &#37;49, &#37;47
   &#37;57 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;29, i64 &#37;56
   &#37;58 &#61; load double, double addrspace&#40;13&#41;* &#37;57, align 8
; └
; ┌ @ float.jl:395 within &#96;&#43;&#39;
   &#37;59 &#61; fadd double &#37;55, &#37;58
; └
;  @ none:4 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:769 within &#96;setindex&#33;&#39;
   &#37;60 &#61; add i64 &#37;49, &#37;48
   &#37;61 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;39, i64 &#37;60
   store double &#37;59, double addrspace&#40;13&#41;* &#37;61, align 8
; └
; ┌ @ range.jl:594 within &#96;iterate&#39;
; │┌ @ promotion.jl:403 within &#96;&#61;&#61;&#39;
    &#37;62 &#61; icmp eq i64 &#37;value_phi224.us.us.us.us, 100
; └└
  br i1 &#37;62, label &#37;L25.us, label &#37;L24.us.us.us.us

L24.us.us.us.us:                                  ; preds &#61; &#37;idxend9.us.us.
us.us
; ┌ @ range.jl:595 within &#96;iterate&#39;
; │┌ @ int.jl:53 within &#96;&#43;&#39;
    &#37;63 &#61; add nuw nsw i64 &#37;value_phi224.us.us.us.us, 1
; └└
;  @ none:3 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:730 within &#96;getindex&#39;
   &#37;64 &#61; icmp ult i64 &#37;value_phi224.us.us.us.us, &#37;10
   br i1 &#37;64, label &#37;idxend.us.us.us.us, label &#37;oob

L36:                                              ; preds &#61; &#37;L25.us
; └
;  @ none:4 within &#96;inner_noalloc&#33;&#39;
  ret &#37;jl_value_t addrspace&#40;10&#41;* addrspacecast &#40;&#37;jl_value_t* inttoptr &#40;i64 
252772360 to &#37;jl_value_t*&#41; to &#37;jl_value_t addrspace&#40;10&#41;*&#41;

oob:                                              ; preds &#61; &#37;ib.lr.ph.us, &#37;
L24.us.us.us.us, &#37;top
  &#37;value_phi.lcssa &#61; phi i64 &#91; 1, &#37;top &#93;, &#91; &#37;value_phi30.us, &#37;L24.us.us.us.
us &#93;, &#91; &#37;value_phi30.us, &#37;ib.lr.ph.us &#93;
  &#37;value_phi2.lcssa &#61; phi i64 &#91; 1, &#37;top &#93;, &#91; &#37;63, &#37;L24.us.us.us.us &#93;, &#91; 1, 
&#37;ib.lr.ph.us &#93;
;  @ none:3 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:730 within &#96;getindex&#39;
   &#37;65 &#61; alloca &#91;2 x i64&#93;, align 8
   &#37;.sub &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;65, i64 0, i64 0
   store i64 &#37;value_phi2.lcssa, i64* &#37;.sub, align 8
   &#37;66 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;65, i64 0, i64 1
   store i64 &#37;value_phi.lcssa, i64* &#37;66, align 8
   &#37;67 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;5 to &#37;jl_value_t addrspa
ce&#40;12&#41;*
   call void @jl_bounds_error_ints&#40;&#37;jl_value_t addrspace&#40;12&#41;* &#37;67, i64* non
null &#37;.sub, i64 2&#41;
   unreachable

oob5:                                             ; preds &#61; &#37;ib.lr.ph.split
.us.us, &#37;idxend.us.us.us.us, &#37;idxend.us.us.us
   &#37;value_phi2.lcssa18.ph.us &#61; phi i64 &#91; 1, &#37;idxend.us.us.us &#93;, &#91; &#37;value_ph
i224.us.us.us.us, &#37;idxend.us.us.us.us &#93;, &#91; 1, &#37;ib.lr.ph.split.us.us &#93;
   &#37;68 &#61; alloca &#91;2 x i64&#93;, align 8
   &#37;.sub16 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;68, i64 0, i64 0
   store i64 &#37;value_phi2.lcssa18.ph.us, i64* &#37;.sub16, align 8
   &#37;69 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;68, i64 0, i64 1
   store i64 &#37;value_phi30.us, i64* &#37;69, align 8
   &#37;70 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;14 to &#37;jl_value_t addrsp
ace&#40;12&#41;*
   call void @jl_bounds_error_ints&#40;&#37;jl_value_t addrspace&#40;12&#41;* &#37;70, i64* non
null &#37;.sub16, i64 2&#41;
   unreachable

oob8:                                             ; preds &#61; &#37;idxend6.us.us.
us.us, &#37;idxend.us.us.us
   &#37;value_phi2.lcssa19.ph.us.ph.us.ph.us &#61; phi i64 &#91; 1, &#37;idxend.us.us.us &#93;,
 &#91; &#37;value_phi224.us.us.us.us, &#37;idxend6.us.us.us.us &#93;
; └
;  @ none:4 within &#96;inner_noalloc&#33;&#39;
; ┌ @ array.jl:769 within &#96;setindex&#33;&#39;
   &#37;71 &#61; alloca &#91;2 x i64&#93;, align 8
   &#37;.sub17 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;71, i64 0, i64 0
   store i64 &#37;value_phi2.lcssa19.ph.us.ph.us.ph.us, i64* &#37;.sub17, align 8
   &#37;72 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;71, i64 0, i64 1
   store i64 &#37;value_phi30.us, i64* &#37;72, align 8
   &#37;73 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;12 to &#37;jl_value_t addrsp
ace&#40;12&#41;*
   call void @jl_bounds_error_ints&#40;&#37;jl_value_t addrspace&#40;12&#41;* &#37;73, i64* non
null &#37;.sub17, i64 2&#41;
   unreachable
; └
&#125;
</pre>


<p>Notice that this <code>getelementptr inbounds</code> stuff is bounds checking. Julia, like all other high level languages, enables bounds checking by default in order to not allow the user to index outside of an array. Indexing outside of an array is dangerous: it can quite easily segfault your system if you change some memory that is unknown beyond your actual array. Thus Julia throws an error:</p>


<pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>101</span><span class='hljl-p'>,</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span>
</pre>


<pre class="julia-error">
ERROR: BoundsError: attempt to access 100×100 Array&#123;Float64,2&#125; at index &#91;101, 1&#93;
</pre>


<p>In tight inner loops, we can remove this bounds checking process using the <code>@inbounds</code> macro:</p>


<pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc_ib!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
6.888 μs &#40;0 allocations: 0 bytes&#41;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc_ib!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
2.399 μs &#40;0 allocations: 0 bytes&#41;
</pre>


<h3>SIMD</h3>
<p>Now let&#39;s inspect the LLVM IR again:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc_ib!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;inner_noalloc_ib&#33;&#39;
; Function Attrs: uwtable
define nonnull &#37;jl_value_t addrspace&#40;10&#41;* @&quot;japi1_inner_noalloc_ib&#33;_22498&quot;&#40;
&#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;**, i32&#41; #0 &#123;
top:
  &#37;3 &#61; alloca &#37;jl_value_t addrspace&#40;10&#41;**, align 8
  store volatile &#37;jl_value_t addrspace&#40;10&#41;** &#37;1, &#37;jl_value_t addrspace&#40;10&#41;*
** &#37;3, align 8
  &#37;4 &#61; load &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;** &#37;1, ali
gn 8
  &#37;5 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrs
pace&#40;10&#41;** &#37;1, i64 1
  &#37;6 &#61; load &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;** &#37;5, ali
gn 8
  &#37;7 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrs
pace&#40;10&#41;** &#37;1, i64 2
  &#37;8 &#61; load &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addrspace&#40;10&#41;** &#37;7, ali
gn 8
  &#37;9 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;6 to &#37;jl_value_t addrspace
&#40;11&#41;*
  &#37;10 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;9 to &#37;jl_value_t addrspace&#40;10&#41;*
 addrspace&#40;11&#41;*
  &#37;11 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addr
space&#40;10&#41;* addrspace&#40;11&#41;* &#37;10, i64 3
  &#37;12 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;11 to i64 addrsp
ace&#40;11&#41;*
  &#37;13 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;12, align 8
  &#37;14 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;9 to double addrspace&#40;13&#41;* addr
space&#40;11&#41;*
  &#37;15 &#61; load double addrspace&#40;13&#41;*, double addrspace&#40;13&#41;* addrspace&#40;11&#41;* &#37;1
4, align 8
  &#37;16 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;8 to &#37;jl_value_t addrspac
e&#40;11&#41;*
  &#37;17 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;16 to &#37;jl_value_t addrspace&#40;10&#41;
* addrspace&#40;11&#41;*
  &#37;18 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addr
space&#40;10&#41;* addrspace&#40;11&#41;* &#37;17, i64 3
  &#37;19 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;18 to i64 addrsp
ace&#40;11&#41;*
  &#37;20 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;19, align 8
  &#37;21 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;16 to double addrspace&#40;13&#41;* add
rspace&#40;11&#41;*
  &#37;22 &#61; load double addrspace&#40;13&#41;*, double addrspace&#40;13&#41;* addrspace&#40;11&#41;* &#37;2
1, align 8
  &#37;23 &#61; addrspacecast &#37;jl_value_t addrspace&#40;10&#41;* &#37;4 to &#37;jl_value_t addrspac
e&#40;11&#41;*
  &#37;24 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;23 to &#37;jl_value_t addrspace&#40;10&#41;
* addrspace&#40;11&#41;*
  &#37;25 &#61; getelementptr inbounds &#37;jl_value_t addrspace&#40;10&#41;*, &#37;jl_value_t addr
space&#40;10&#41;* addrspace&#40;11&#41;* &#37;24, i64 3
  &#37;26 &#61; bitcast &#37;jl_value_t addrspace&#40;10&#41;* addrspace&#40;11&#41;* &#37;25 to i64 addrsp
ace&#40;11&#41;*
  &#37;27 &#61; load i64, i64 addrspace&#40;11&#41;* &#37;26, align 8
  &#37;28 &#61; bitcast &#37;jl_value_t addrspace&#40;11&#41;* &#37;23 to double addrspace&#40;13&#41;* add
rspace&#40;11&#41;*
  &#37;29 &#61; load double addrspace&#40;13&#41;*, double addrspace&#40;13&#41;* addrspace&#40;11&#41;* &#37;2
8, align 8
  br label &#37;L2

L2:                                               ; preds &#61; &#37;L25, &#37;top
  &#37;indvar &#61; phi i64 &#91; &#37;indvar.next, &#37;L25 &#93;, &#91; 0, &#37;top &#93;
  &#37;value_phi &#61; phi i64 &#91; &#37;65, &#37;L25 &#93;, &#91; 1, &#37;top &#93;
  &#37;30 &#61; mul i64 &#37;27, &#37;indvar
  &#37;scevgep &#61; getelementptr double, double addrspace&#40;13&#41;* &#37;29, i64 &#37;30
  &#37;31 &#61; add i64 &#37;30, 100
  &#37;scevgep11 &#61; getelementptr double, double addrspace&#40;13&#41;* &#37;29, i64 &#37;31
  &#37;32 &#61; mul i64 &#37;13, &#37;indvar
  &#37;33 &#61; mul i64 &#37;20, &#37;indvar
  &#37;34 &#61; add nsw i64 &#37;value_phi, -1
  &#37;35 &#61; mul i64 &#37;13, &#37;34
  &#37;36 &#61; mul i64 &#37;20, &#37;34
  &#37;37 &#61; mul i64 &#37;27, &#37;34
  &#37;38 &#61; add i64 &#37;33, 100
  &#37;scevgep19 &#61; getelementptr double, double addrspace&#40;13&#41;* &#37;22, i64 &#37;38
  &#37;scevgep17 &#61; getelementptr double, double addrspace&#40;13&#41;* &#37;22, i64 &#37;33
  &#37;39 &#61; add i64 &#37;32, 100
  &#37;scevgep15 &#61; getelementptr double, double addrspace&#40;13&#41;* &#37;15, i64 &#37;39
  &#37;scevgep13 &#61; getelementptr double, double addrspace&#40;13&#41;* &#37;15, i64 &#37;32
  &#37;bound0 &#61; icmp ult double addrspace&#40;13&#41;* &#37;scevgep, &#37;scevgep15
  &#37;bound1 &#61; icmp ult double addrspace&#40;13&#41;* &#37;scevgep13, &#37;scevgep11
  &#37;found.conflict &#61; and i1 &#37;bound0, &#37;bound1
  &#37;bound021 &#61; icmp ult double addrspace&#40;13&#41;* &#37;scevgep, &#37;scevgep19
  &#37;bound122 &#61; icmp ult double addrspace&#40;13&#41;* &#37;scevgep17, &#37;scevgep11
  &#37;found.conflict23 &#61; and i1 &#37;bound021, &#37;bound122
  &#37;conflict.rdx &#61; or i1 &#37;found.conflict, &#37;found.conflict23
  br i1 &#37;conflict.rdx, label &#37;scalar.ph, label &#37;vector.ph

vector.ph:                                        ; preds &#61; &#37;L2
  br label &#37;vector.body

vector.body:                                      ; preds &#61; &#37;vector.body, &#37;
vector.ph
  &#37;index &#61; phi i64 &#91; 0, &#37;vector.ph &#93;, &#91; &#37;index.next, &#37;vector.body &#93;
  &#37;offset.idx &#61; or i64 &#37;index, 1
;  @ none:3 within &#96;inner_noalloc_ib&#33;&#39;
; ┌ @ array.jl:730 within &#96;getindex&#39;
   &#37;40 &#61; add nsw i64 &#37;offset.idx, -1
   &#37;41 &#61; add i64 &#37;40, &#37;35
   &#37;42 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;15, i64 &#37;41
   &#37;43 &#61; bitcast double addrspace&#40;13&#41;* &#37;42 to &lt;4 x double&gt; addrspace&#40;13&#41;*
   &#37;wide.load &#61; load &lt;4 x double&gt;, &lt;4 x double&gt; addrspace&#40;13&#41;* &#37;43, align 8
   &#37;44 &#61; add i64 &#37;40, &#37;36
   &#37;45 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;22, i64 &#37;44
   &#37;46 &#61; bitcast double addrspace&#40;13&#41;* &#37;45 to &lt;4 x double&gt; addrspace&#40;13&#41;*
   &#37;wide.load24 &#61; load &lt;4 x double&gt;, &lt;4 x double&gt; addrspace&#40;13&#41;* &#37;46, align
 8
; └
; ┌ @ float.jl:395 within &#96;&#43;&#39;
   &#37;47 &#61; fadd &lt;4 x double&gt; &#37;wide.load, &#37;wide.load24
; └
;  @ none:4 within &#96;inner_noalloc_ib&#33;&#39;
; ┌ @ array.jl:769 within &#96;setindex&#33;&#39;
   &#37;48 &#61; add i64 &#37;40, &#37;37
   &#37;49 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;29, i64 &#37;48
   &#37;50 &#61; bitcast double addrspace&#40;13&#41;* &#37;49 to &lt;4 x double&gt; addrspace&#40;13&#41;*
   store &lt;4 x double&gt; &#37;47, &lt;4 x double&gt; addrspace&#40;13&#41;* &#37;50, align 8
   &#37;index.next &#61; add i64 &#37;index, 4
   &#37;51 &#61; icmp eq i64 &#37;index.next, 100
   br i1 &#37;51, label &#37;L25, label &#37;vector.body

scalar.ph:                                        ; preds &#61; &#37;L2
; └
;  @ none:2 within &#96;inner_noalloc_ib&#33;&#39;
  br label &#37;L5

L5:                                               ; preds &#61; &#37;L5, &#37;scalar.ph
  &#37;value_phi2 &#61; phi i64 &#91; 1, &#37;scalar.ph &#93;, &#91; &#37;63, &#37;L5 &#93;
;  @ none:3 within &#96;inner_noalloc_ib&#33;&#39;
; ┌ @ array.jl:730 within &#96;getindex&#39;
   &#37;52 &#61; add nsw i64 &#37;value_phi2, -1
   &#37;53 &#61; add i64 &#37;52, &#37;35
   &#37;54 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;15, i64 &#37;53
   &#37;55 &#61; load double, double addrspace&#40;13&#41;* &#37;54, align 8
   &#37;56 &#61; add i64 &#37;52, &#37;36
   &#37;57 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;22, i64 &#37;56
   &#37;58 &#61; load double, double addrspace&#40;13&#41;* &#37;57, align 8
; └
; ┌ @ float.jl:395 within &#96;&#43;&#39;
   &#37;59 &#61; fadd double &#37;55, &#37;58
; └
;  @ none:4 within &#96;inner_noalloc_ib&#33;&#39;
; ┌ @ array.jl:769 within &#96;setindex&#33;&#39;
   &#37;60 &#61; add i64 &#37;52, &#37;37
   &#37;61 &#61; getelementptr inbounds double, double addrspace&#40;13&#41;* &#37;29, i64 &#37;60
   store double &#37;59, double addrspace&#40;13&#41;* &#37;61, align 8
; └
; ┌ @ range.jl:594 within &#96;iterate&#39;
; │┌ @ promotion.jl:403 within &#96;&#61;&#61;&#39;
    &#37;62 &#61; icmp eq i64 &#37;value_phi2, 100
; │└
; │ @ range.jl:595 within &#96;iterate&#39;
; │┌ @ int.jl:53 within &#96;&#43;&#39;
    &#37;63 &#61; add nuw nsw i64 &#37;value_phi2, 1
; └└
  br i1 &#37;62, label &#37;L25, label &#37;L5

L25:                                              ; preds &#61; &#37;vector.body, &#37;
L5
; ┌ @ range.jl:594 within &#96;iterate&#39;
; │┌ @ promotion.jl:403 within &#96;&#61;&#61;&#39;
    &#37;64 &#61; icmp eq i64 &#37;value_phi, 100
; │└
; │ @ range.jl:595 within &#96;iterate&#39;
; │┌ @ int.jl:53 within &#96;&#43;&#39;
    &#37;65 &#61; add nuw nsw i64 &#37;value_phi, 1
; └└
  &#37;indvar.next &#61; add i64 &#37;indvar, 1
  br i1 &#37;64, label &#37;L36, label &#37;L2

L36:                                              ; preds &#61; &#37;L25
  ret &#37;jl_value_t addrspace&#40;10&#41;* addrspacecast &#40;&#37;jl_value_t* inttoptr &#40;i64 
252772360 to &#37;jl_value_t*&#41; to &#37;jl_value_t addrspace&#40;10&#41;*&#41;
&#125;
</pre>


<p>If you look closely, you will see things like:</p>
<pre><code>&#37;wide.load24 &#61; load &lt;4 x double&gt;, &lt;4 x double&gt; addrspac&#40;13&#41;* &#37;46, align 8
; └
; ┌ @ float.jl:395 within &#96;&#43;&#39;
&#37;47 &#61; fadd &lt;4 x double&gt; &#37;wide.load, &#37;wide.load24</code></pre>
<p>What this is saying is that it&#39;s loading and adding 4 <code>Float64</code>s at a time&#33; This feature of the processor is known as SIMD: single input multiple data. If certain primative floating point operations, like <code>&#43;</code> and <code>*</code>, are done in succession &#40;i.e. no inbounds checks between them&#33;&#41;, then the processor can lump them together and do multiples at once. Since clock cycles have stopped improving while transistors have gotten smaller, this &quot;lumping&quot; has been a big source of speedups in computational mathematics even though the actual <code>&#43;</code> and <code>*</code> hasn&#39;t gotten faster. Thus to get full speed we want to make sure this is utilized whenever possible, which essentially just amounts to doing type inferred loops with no branches or bounds checks in the way.</p>
<h3>FMA</h3>
<p>Modern processors have a single operation that fuses the multiplication and the addition in the operation <code>x*y&#43;z</code>, known as a <em>fused multiply-add</em> or FMA. Note that FMA has less floating point roundoff error than the two operation form. We can see this intrinsic in the resulting LLVM IR:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>fma</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>5.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>3.0</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ floatfuncs.jl:320 within &#96;fma&#39;
; Function Attrs: uwtable
define double @julia_fma_22507&#40;double, double, double&#41; #0 &#123;
top:
; ┌ @ floatfuncs.jl:309 within &#96;fma_llvm&#39;
   &#37;3 &#61; call double @llvm.fma.f64&#40;double &#37;0, double &#37;1, double &#37;2&#41;
; └
  ret double &#37;3
&#125;
</pre>


<p>The Julia function <code>muladd</code> will automatically choose between FMA and the original form depending on the availability of the routine in the processor. The MuladdMacro.jl package has a macro <code>@muladd</code> which pulls apart statements to add <code>muladd</code> expressions. For example, <code>x1*y1 &#43; x2*y2 &#43; x3*y3</code> can be rewritten as:</p>
<pre><code>muladd&#40;x1,y1,muladd&#40;x2,y2,x3*y3&#41;&#41;</code></pre>
<p>Which reduces the linear combination to just 3 arithmetic operations. FMA operations can be SIMD&#39;d.</p>
<h3>Inlining</h3>
<p>All of this would go to waste if function call costs of 50 clock cycles were interrupting every single <code>&#43;</code>. Fortunately these function calls disappear during the compilation process due to what&#39;s known as inlining. Essentially, if the function call is determined to be &quot;cheap enough&quot;, the actual function call is removed and the code is basically pasted into the function caller. We can force a function call to occur by teling it to not inline:</p>


<pre class='hljl'>
<span class='hljl-nd'>@noinline</span><span class='hljl-t'> </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-cs'># Can add @inline, but this is automatic here</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>qnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class="output">
qnoinline &#40;generic function with 1 method&#41;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;qinline&#39;
; Function Attrs: uwtable
define double @julia_qinline_22508&#40;double, double&#41; #0 &#123;
top:
;  @ none:4 within &#96;qinline&#39;
; ┌ @ none:1 within &#96;finline&#39;
; │┌ @ promotion.jl:313 within &#96;&#43;&#39; @ float.jl:395
    &#37;2 &#61; fadd double &#37;0, 4.000000e&#43;00
; └└
;  @ none:5 within &#96;qinline&#39;
; ┌ @ none:1 within &#96;finline&#39;
; │┌ @ promotion.jl:313 within &#96;&#43;&#39; @ float.jl:395
    &#37;3 &#61; fadd double &#37;2, 2.000000e&#43;00
; └└
;  @ none:6 within &#96;qinline&#39;
; ┌ @ none:1 within &#96;finline&#39;
; │┌ @ float.jl:395 within &#96;&#43;&#39;
    &#37;4 &#61; fadd double &#37;3, &#37;1
; └└
  ret double &#37;4
&#125;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>qnoinline</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
;  @ none:2 within &#96;qnoinline&#39;
; Function Attrs: uwtable
define double @julia_qnoinline_22509&#40;double, double&#41; #0 &#123;
top:
;  @ none:4 within &#96;qnoinline&#39;
  &#37;2 &#61; call double @julia_fnoinline_22510&#40;double &#37;0, i64 4&#41;
;  @ none:5 within &#96;qnoinline&#39;
  &#37;3 &#61; call double @julia_fnoinline_22511&#40;i64 2, double &#37;2&#41;
;  @ none:6 within &#96;qnoinline&#39;
  &#37;4 &#61; call double @julia_fnoinline_22512&#40;double &#37;3, double &#37;1&#41;
  ret double &#37;4
&#125;
</pre>


<p>We can see now that it keeps the function calls:</p>
<pre><code>&#37;4 &#61; call double @julia_fnoinline_21538&#40;double &#37;3, double &#37;1&#41;</code></pre>
<p>and this is slower in comparison to what we had before &#40;but it still infers&#41;.</p>


<pre class='hljl'>
<span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-t'>
</span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
20.048 ns &#40;1 allocation: 16 bytes&#41;
9.0
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>qnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span>
</pre>


<pre class="output">
24.674 ns &#40;1 allocation: 16 bytes&#41;
9.0
</pre>


<p>Note that if we ever want to go the other direction and tell Julia to inline as much as possible, one can use the macro <code>@inline</code>.</p>
<h3>Summary</h3>
<ul>
<li><p>Scalar operations are super cheap, and if they are cache-aligned then more than one will occur in a clock cycle.</p>
</li>
<li><p>Inlining a function will remove the high function call overhead.</p>
</li>
<li><p>Branch prediction is pretty good these days, so keep them out of super tight inner loops but don&#39;t worry all too much about them.</p>
</li>
<li><p>Cache misses are quite expensive the futher out it goes.</p>
</li>
</ul>
<h2>Note on Benchmarking</h2>
<p>Julia&#39;s compiler is smart. This means that if you don&#39;t try hard enough, Julia&#39;s compiler might get rid of your issues. For example, it can delete branches and directly compute the result if all of the values are known at compile time. So be very careful when benchmarking: your tests may have just compiled away&#33;</p>
<h2>Conclusion</h2>
<p>Optimize your serial code before you parallelize. There&#39;s a lot to think about.</p>



          <HR/>
          <div class="footer"><p>
          Published from <a href="optimizing.jmd">optimizing.jmd</a> using
          <a href="http://github.com/mpastell/Weave.jl">Weave.jl</a>
           on 2019-09-04.
          <p></div>


        </div>
      </div>
    </div>
  </BODY>
</HTML>
